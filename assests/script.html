<!DOCTYPE html>
<html>
<head>
<script type="module">
import { FaceLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";

const video = document.getElementById("webcam");
const staticImg = document.getElementById("static-img");
const canvas = document.getElementById("overlay");
const ctx = canvas.getContext("2d");
const triggerBtn = document.getElementById("trigger-btn"); 

// --- PYTHON VARIABLES INJECTED HERE ---
const staticImgSrc = "STATIC_IMG_PLACEHOLDER";
const runMode = "RUN_MODE_PLACEHOLDER";
const registry = JSON.parse('DB_JSON_PLACEHOLDER');

let faceLandmarker;
let lastVideoTime = -1;
let currentMatch = "Unknown";
let matchStartTime = 0;

// --- GEOMETRIC MATH ---
function getDist3D(p1, p2) {
    return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2) + Math.pow(p1.z - p2.z, 2));
}

// Pose Guard: Check if looking straight
function isFaceFrontal(landmarks) {
    const nose = landmarks[1];
    const leftEar = landmarks[234];
    const rightEar = landmarks[454];
    const distL = getDist3D(nose, leftEar);
    const distR = getDist3D(nose, rightEar);
    const ratio = Math.min(distL, distR) / Math.max(distL, distR);
    if (ratio < 0.5) return false;
    return true;
}

function getFaceVector(landmarks) {
    const P = (idx) => landmarks[idx]; 
    const eyeDist = getDist3D(P(468), P(473));
    // 14 Invariant Ratios
    const features = [
        [1, 4], [1, 61], [1, 291], [61, 291], [33, 133], [263, 362], 
        [1, 152], [10, 152], [234, 454], [1, 468], [1, 473], 
        [152, 234], [152, 454], [10, 1]
    ];
    return features.map(pair => getDist3D(P(pair[0]), P(pair[1])) / eyeDist);
}

function calculateScore(vecA, vecB) {
    let diff = 0;
    for (let i = 0; i < vecA.length; i++) diff += Math.abs(vecA[i] - vecB[i]);
    return diff;
}

function findMatch(landmarks) {
    const currentVec = getFaceVector(landmarks);
    let bestMatch = { name: "Unknown", score: 1000.0 }; 

    for (const [name, savedLandmarks] of Object.entries(registry)) {
        const savedVec = getFaceVector(savedLandmarks);
        const score = calculateScore(currentVec, savedVec);
        if (score < bestMatch.score) bestMatch = { name: name, score: score };
    }
    
    // Strict Threshold
    if (bestMatch.score < 0.65) return bestMatch.name;
    return "Unknown";
}

async function init() {
    const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
    faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
        baseOptions: {
            modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task",
            delegate: "GPU"
        },
        runningMode: runMode,
        numFaces: 1
    });

    if (staticImgSrc !== "null") {
        staticImg.src = staticImgSrc;
        staticImg.onload = async () => {
            const results = await faceLandmarker.detect(staticImg);
            if (results.faceLandmarks.length > 0) {
                const dataStr = btoa(JSON.stringify(results.faceLandmarks[0]));
                const url = new URL(window.parent.location.href);
                url.searchParams.set("face_data", dataStr);
                window.parent.history.replaceState({}, "", url);
                if(triggerBtn) triggerBtn.click(); 
            }
        }
    } else {
        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
        video.srcObject = stream;
        video.addEventListener("loadeddata", predictVideo);
    }
}

async function predictVideo() {
    const now = performance.now();
    
    if (lastVideoTime !== video.currentTime) {
        lastVideoTime = video.currentTime;
        const results = faceLandmarker.detectForVideo(video, now);
        
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (results.faceLandmarks.length > 0) {
            const landmarks = results.faceLandmarks[0];
            
            // 1. POSE CHECK
            const isFrontal = isFaceFrontal(landmarks);
            
            let name = "Unknown";
            let color = "#FF0000"; 
            let label = "UNKNOWN";

            if (!isFrontal) {
                name = "Unknown";
                label = "LOOK STRAIGHT";
                color = "#FF4B4B";
            } else {
                name = findMatch(landmarks);
                
                // Stability Logic
                if (name !== currentMatch) {
                    currentMatch = name;
                    matchStartTime = now;
                }

                const timeElapsed = now - matchStartTime;
                const isUnknown = (currentMatch === "Unknown");
                const isVerified = (!isUnknown && timeElapsed > 1000); 

                if (!isUnknown) {
                    if (isVerified) {
                        color = "#00FF00"; 
                        label = currentMatch; 
                        
                        // Send to Python
                        try {
                            const url = new URL(window.parent.location.href);
                            if (url.searchParams.get("detected_name") !== currentMatch) {
                                url.searchParams.set("detected_name", currentMatch);
                                // Client Time Sync
                                const d = new Date();
                                const dateStr = d.getFullYear() + "-" + (d.getMonth()+1).toString().padStart(2, '0') + "-" + d.getDate().toString().padStart(2, '0');
                                const timeStr = d.getHours().toString().padStart(2, '0') + ":" + d.getMinutes().toString().padStart(2, '0') + ":" + d.getSeconds().toString().padStart(2, '0');
                                
                                url.searchParams.set("c_date", dateStr);
                                url.searchParams.set("c_time", timeStr);
                                url.searchParams.set("ts", Date.now()); 
                                
                                window.parent.history.replaceState({}, "", url);
                                if(triggerBtn) triggerBtn.click();
                            }
                        } catch(e) {}
                        
                    } else {
                        color = "#FFFF00"; 
                        label = "VERIFYING..."; 
                    }
                }
            }

            // Draw
            ctx.strokeStyle = color; ctx.lineWidth = 4; ctx.strokeRect(landmarks[1].x, landmarks[1].y, 10, 10); // Debug point
            
            // Re-calculate Box based on landmarks
            const xs = landmarks.map(p => p.x * canvas.width);
            const ys = landmarks.map(p => p.y * canvas.height);
            const x = Math.min(...xs); const y = Math.min(...ys);
            const w = Math.max(...xs) - x; const h = Math.max(...ys) - y;

            ctx.strokeRect(x, y, w, h);
            ctx.fillStyle = color; ctx.fillRect(x, y - 30, w, 30);
            ctx.fillStyle = "#000"; ctx.font = "bold 16px sans-serif"; ctx.fillText(label, x + 5, y - 8);
        }
    }
    window.requestAnimationFrame(predictVideo);
}

init();
</script>
<style>
    body { margin:0; background:black; overflow:hidden; }
    #view { position:relative; width:100%; height:100vh; }
    video, canvas, img { position:absolute; top:0; left:0; width:100%; height:100%; object-fit:contain; }
</style>
</head>
<body>
    <div id="view">
        <video id="webcam" autoplay muted playsinline style="display: {'none' if img_b64 else 'block'}"></video>
        <img id="static-img" style="display: {'block' if img_b64 else 'none'}">
        <canvas id="overlay"></canvas>
        <button id="trigger-btn" style="display:none;" onclick="window.parent.postMessage({type: 'streamlit:setComponentValue', value: 'update'}, '*')"></button>
    </div>
</body>
</html>
