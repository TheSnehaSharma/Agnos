<!DOCTYPE html>
<html>
<head>
<script type="module">
import { FaceLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";

const video = document.getElementById("webcam");
const staticImg = document.getElementById("static-img");
const canvas = document.getElementById("overlay");
const ctx = canvas.getContext("2d");
const logger = document.getElementById("status-log");

// INJECTED VARIABLES
const staticImgSrc = "STATIC_IMG_PLACEHOLDER";
const runMode = "RUN_MODE_PLACEHOLDER";
const registry = JSON.parse('DB_JSON_PLACEHOLDER');

let faceLandmarker;
let lastVideoTime = -1;
let currentMatch = "Unknown";
let matchStartTime = 0;

function log(msg) {
    if(logger) logger.innerText = "SYSTEM: " + msg;
}

// --- MATH ---
function getDist3D(p1, p2) {
    return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2) + Math.pow(p1.z - p2.z, 2));
}

function isFaceFrontal(landmarks) {
    const nose = landmarks[1];
    const leftEar = landmarks[234];
    const rightEar = landmarks[454];
    const distL = getDist3D(nose, leftEar);
    const distR = getDist3D(nose, rightEar);
    const ratio = Math.min(distL, distR) / Math.max(distL, distR);
    return ratio > 0.5; 
}

function getFaceVector(landmarks) {
    const P = (idx) => landmarks[idx]; 
    const eyeDist = getDist3D(P(468), P(473)); 
    const features = [
        [1, 4], [1, 61], [1, 291], [61, 291], [33, 133], [263, 362], 
        [1, 152], [10, 152], [234, 454], [1, 468], [1, 473], 
        [152, 234], [152, 454], [10, 1]
    ];
    return features.map(pair => getDist3D(P(pair[0]), P(pair[1])) / eyeDist);
}

function calculateScore(vecA, vecB) {
    let diff = 0;
    for (let i = 0; i < vecA.length; i++) diff += Math.abs(vecA[i] - vecB[i]);
    return diff;
}

function findMatch(landmarks) {
    const currentVec = getFaceVector(landmarks);
    let bestMatch = { name: "Unknown", score: 1000.0 }; 

    for (const [name, savedLandmarks] of Object.entries(registry)) {
        const savedVec = getFaceVector(savedLandmarks);
        const score = calculateScore(currentVec, savedVec);
        if (score < bestMatch.score) bestMatch = { name: name, score: score };
    }
    
    if (bestMatch.score < 0.65) return bestMatch.name;
    return "Unknown";
}

async function init() {
    log("Loading AI...");
    try {
        const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
        faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
            baseOptions: {
                modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task",
                delegate: "GPU"
            },
            runningMode: runMode,
            numFaces: 1
        });
        log("Ready.");

        if (staticImgSrc !== "null") {
            staticImg.src = staticImgSrc;
            staticImg.onload = async () => {
                const results = await faceLandmarker.detect(staticImg);
                if (results.faceLandmarks.length > 0) {
                    const dataStr = btoa(JSON.stringify(results.faceLandmarks[0]));
                    const url = new URL(window.parent.location.href);
                    url.searchParams.set("face_data", dataStr);
                    window.parent.history.replaceState({}, "", url);
                }
            }
        } else {
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            video.srcObject = stream;
            video.addEventListener("loadeddata", () => {
                log("Active.");
                predictVideo();
            });
        }
    } catch (err) {
        log("ERR: " + err.message);
    }
}

// --- STATE MANAGEMENT ---
function manageState(name) {
    const url = new URL(window.parent.location.href);
    const urlName = url.searchParams.get("detected_name");

    // 1. Stable State: If we see what the URL says, do nothing.
    if (name === urlName) return;

    // 2. Change State
    if (name === "Unknown") {
        // Soft clear (no reload needed)
        url.searchParams.delete("detected_name");
        url.searchParams.delete("c_date");
        url.searchParams.delete("c_time");
        window.parent.history.replaceState({}, "", url);
    } else {
        // New Person -> Hard Reload to Trigger Python
        url.searchParams.set("detected_name", name);
        
        const d = new Date();
        const dateStr = d.getFullYear() + "-" + (d.getMonth()+1).toString().padStart(2, '0') + "-" + d.getDate().toString().padStart(2, '0');
        const timeStr = d.getHours().toString().padStart(2, '0') + ":" + d.getMinutes().toString().padStart(2, '0') + ":" + d.getSeconds().toString().padStart(2, '0');
        
        url.searchParams.set("c_date", dateStr);
        url.searchParams.set("c_time", timeStr);
        
        window.parent.location.href = url.toString();
    }
}

async function predictVideo() {
    const now = performance.now();
    
    // Auto-Resize Canvas
    if (canvas.width !== video.videoWidth) {
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
    }

    if (video.currentTime !== lastVideoTime) {
        lastVideoTime = video.currentTime;
        
        try {
            const results = faceLandmarker.detectForVideo(video, now);
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (results.faceLandmarks.length > 0) {
                const landmarks = results.faceLandmarks[0];
                
                // --- POSE CHECK ---
                if (!isFaceFrontal(landmarks)) {
                     drawBox(landmarks, "#FF4B4B", "LOOK STRAIGHT");
                     manageState("Unknown"); 
                } else {
                    const name = findMatch(landmarks);

                    // --- TIMER LOGIC ---
                    if (name !== currentMatch) {
                        currentMatch = name;
                        matchStartTime = now;
                    }

                    const timeElapsed = now - matchStartTime;
                    const isUnknown = (currentMatch === "Unknown");
                    
                    // --- PRE-VERIFICATION (THE FIX) ---
                    // If the URL already matches the face, we trust it instantly.
                    const urlName = new URL(window.parent.location.href).searchParams.get("detected_name");
                    const isPreVerified = (currentMatch === urlName && !isUnknown);
                    
                    // Verified if: Already verified OR Timer passed
                    const isVerified = isPreVerified || (!isUnknown && timeElapsed > 1000); 

                    // --- DRAW FIRST, THEN MANAGE STATE ---
                    if (isVerified) {
                        drawBox(landmarks, "#00FF00", currentMatch);
                        manageState(currentMatch); // This might reload the page
                    } else if (!isUnknown) {
                        drawBox(landmarks, "#FFFF00", "VERIFYING...");
                    } else {
                        drawBox(landmarks, "#FF0000", "UNKNOWN");
                        manageState("Unknown");
                    }
                }
            } else {
                currentMatch = "Unknown";
                manageState("Unknown");
            }
        } catch (e) {}
    }
    window.requestAnimationFrame(predictVideo);
}

function drawBox(landmarks, color, text) {
    const xs = landmarks.map(p => p.x * canvas.width);
    const ys = landmarks.map(p => p.y * canvas.height);
    const x = Math.min(...xs), y = Math.min(...ys), w = Math.max(...xs)-x, h = Math.max(...ys)-y;
    
    ctx.strokeStyle = color; ctx.lineWidth = 4; ctx.strokeRect(x, y, w, h);
    ctx.fillStyle = color; ctx.fillRect(x, y - 30, w, 30);
    ctx.fillStyle = "#000"; ctx.font = "bold 16px sans-serif"; ctx.fillText(text, x + 5, y - 8);
}

init();
</script>
<style>
    body { margin:0; background:black; overflow:hidden; }
    #view { position:relative; width:100%; height:100vh; }
    video, canvas, img { position:absolute; top:0; left:0; width:100%; height:100%; object-fit:contain; }
    #status-log {
        position: absolute; top: 10px; left: 10px; z-index: 20;
        color: #00FF00; background: rgba(0,0,0,0.7); padding: 5px 10px;
        border-radius: 4px; font-size: 12px; font-family: monospace; pointer-events: none;
    }
</style>
</head>
<body>
    <div id="view">
        <div id="status-log">Initializing...</div>
        <video id="webcam" autoplay muted playsinline style="display: {'none' if img_b64 else 'block'}"></video>
        <img id="static-img" style="display: {'block' if img_b64 else 'none'}">
        <canvas id="overlay"></canvas>
    </div>
</body>
</html>
